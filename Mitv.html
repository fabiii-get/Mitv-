<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>Simulador TikTok (Embeds que funcionan)</title>
  <style>
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Arial}
    .feed{height:100vh;overflow:auto;scroll-snap-type:y mandatory;scrollbar-width:none}
    .feed::-webkit-scrollbar{display:none}
    .item{display:flex;justify-content:center;align-items:center;height:100vh;scroll-snap-align:start;padding:0 10px}
    .wrap{width:100%;max-width:500px;margin:0 auto}
    .stack-right{position:fixed;right:12px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:14px}
    .bigbtn{width:64px;height:64px;border-radius:999px;border:none;cursor:pointer;background:#ffffff2a;color:#fff;font-size:28px;backdrop-filter: blur(6px)}
    .bigbtn:active{transform:scale(.98)}
    .gate{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:10}
    .gate button{font-size:1rem;padding:.9rem 1.2rem;border-radius:999px;border:0;background:#fff;color:#000;cursor:pointer}
  </style>
</head>
<body>
  <!-- Gate para primer toque en móvil -->
  <div class="gate" id="gate">
    <button id="start">▶️ Iniciar</button>
  </div>

  <div class="feed" id="feed">
    <section class="item">
      <div class="wrap">
        <!-- Reemplaza URL_TIKTOK_1 por la URL larga con /@usuario/video/ID -->
        <blockquote class="tiktok-embed" cite="URL_TIKTOK_1" data-video-id="" style="background:#000" >
          <section> <a href="URL_TIKTOK_1"></a> </section>
        </blockquote>
      </div>
    </section>

    <section class="item">
      <div class="wrap">
        <!-- Reemplaza URL_TIKTOK_2 por la URL larga con /@usuario/video/ID -->
        <blockquote class="tiktok-embed" cite="URL_TIKTOK_2" data-video-id="" style="background:#000">
          <section> <a href="URL_TIKTOK_2"></a> </section>
        </blockquote>
      </div>
    </section>
  </div>

  <!-- Botones arriba/abajo -->
  <div class="stack-right">
    <button class="bigbtn" id="btnPrev" aria-label="Anterior">⬆️</button>
    <button class="bigbtn" id="btnNext" aria-label="Siguiente">⬇️</button>
  </div>

  <!-- SDK oficial (debe ir después de los blockquotes) -->
  <script async src="https://www.tiktok.com/embed.js"></script>

  <script>
    const sections = Array.from(document.querySelectorAll('.item'));
    const btnPrev = document.getElementById('btnPrev');
    const btnNext = document.getElementById('btnNext');
    const gate = document.getElementById('gate');
    let current = 0, started = false;

    function go(i){
      if (i<0) i=0;
      if (i>=sections.length) i=sections.length-1;
      current = i;
      sections[i].scrollIntoView({behavior:'smooth', block:'start'});
    }

    // Gestos swipe vertical
    let startY=0, startX=0, moved=false;
    window.addEventListener('touchstart', e=>{ const t=e.touches[0]; startY=t.clientY; startX=t.clientX; moved=false; }, {passive:true});
    window.addEventListener('touchmove', ()=>{ moved=true; }, {passive:true});
    window.addEventListener('touchend', e=>{
      if (!moved) return;
      const t=e.changedTouches[0]; const dy=t.clientY-startY, dx=t.clientX-startX;
      if (Math.abs(dy)>Math.abs(dx) && Math.abs(dy)>40){ dy<0? go(current+1) : go(current-1); }
    }, {passive:true});

    btnPrev.onclick = ()=> go(current-1);
    btnNext.onclick = ()=> go(current+1);

    document.getElementById('start').onclick = ()=>{
      started = true;
      gate.style.display = 'none';
    };

    // Actualiza "current" cuando el usuario hace scroll manual
    const io = new IntersectionObserver(entries=>{
      entries.forEach(e=>{
        if (e.isIntersecting){
          current = sections.findIndex(s=>s===e.target);
        }
      });
    }, {threshold:0.6});
    sections.forEach(s=>io.observe(s));
  </script>
</body>
</html>
    function setControlsState(){
      const videoMode = isVideo();
      // Habilita/Deshabilita controles que no aplican a TikTok
      [btnPlay, btnMute, ...rateChips, progress].forEach(el=>{
        el.classList.toggle('disabled', !videoMode);
      });
      timeLabel.style.opacity = videoMode ? '1' : '.35';
    }

    function fmt(t){
      if (!isFinite(t)) return '0:00';
      const m = Math.floor(t/60);
      const s = Math.floor(t%60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }

    function toastMsg(msg){
      toast.textContent = msg;
      toast.style.opacity = '1';
      setTimeout(()=> toast.style.opacity='0', 900);
    }

    function go(i){
      if (i < 0) i = 0;
      if (i >= sections.length) i = sections.length - 1;
      current = i;
      sections[i].scrollIntoView({behavior:'smooth'});
      setTimeout(()=> userStarted && playVisible(i), 200);
      setControlsState();
    }

    async function playVisible(idx=current){
      // Pausar todos los <video>
      videos.forEach(v => v && v.pause());
      const v = sections[idx].querySelector('video');
      if (!v) { // Es un TikTok (iframe) → sin control programático
        cancelAnimationFrame(rafId);
        progressFill.style.width = '0%';
        timeLabel.textContent = '0:00 / 0:00';
        return;
      }
      v.playbackRate = currentRate;
      v.muted = btnMute.classList.contains('on');
      try { await v.play(); } catch {}
      cancelAnimationFrame(rafId);
      const loop = ()=>{
        if (!v.duration || !isFinite(v.duration)){
          progressFill.style.width = '0%';
          timeLabel.textContent = `${fmt(v.currentTime)} / 0:00`;
        } else {
          const pct = (v.currentTime / v.duration) * 100;
          progressFill.style.width = pct + '%';
          timeLabel.textContent = `${fmt(v.currentTime)} / ${fmt(v.duration)}`;
        }
        rafId = requestAnimationFrame(loop);
      };
      rafId = requestAnimationFrame(loop);
    }

    // Auto siguiente al terminar <video>
    videos.forEach((v, idx)=>{
      if (!v) return;
      v.addEventListener('ended', ()=>{
        if (!autoplayNext) return;
        const next = (idx + 1) % sections.length;
        go(next);
      });
      v.addEventListener('click', ()=>{
        userStarted = true;
        v.paused ? v.play() : v.pause();
      });
      progress.addEventListener('click', e=>{
        if (!isVideo()) return;
        const rect = progress.getBoundingClientRect();
        const frac = (e.clientX - rect.left)/rect.width;
        if (isFinite(v.duration)) v.currentTime = Math.max(0, Math.min(frac,1)) * v.duration;
      });
    });

    // Observador para actualizar "current" por scroll manual
    const io = new IntersectionObserver(entries=>{
      entries.forEach(e=>{
        if (e.isIntersecting){
          current = sections.indexOf ? sections.indexOf(e.target) : sections.findIndex(s=>s===e.target);
          if (userStarted) playVisible(current);
          setControlsState();
        }
      });
    }, {threshold: 0.6});
    sections.forEach(s=>io.observe(s));

    // Gestos táctiles básicos (swipe vertical)
    let startY=0, startX=0, moved=false;
    window.addEventListener('touchstart', e=>{ const t=e.touches[0]; startY=t.clientY; startX=t.clientX; moved=false; }, {passive:true});
    window.addEventListener('touchmove', ()=>{ moved=true; }, {passive:true});
    window.addEventListener('touchend', e=>{
      if (!moved) return;
      const t=e.changedTouches[0];
      const dy=t.clientY-startY, dx=t.clientX-startX;
      if (Math.abs(dy)>Math.abs(dx) && Math.abs(dy)>40){
        dy<0 ? go(current+1) : go(current-1);
      }
    }, {passive:true});

    // Botones
    btnPrev.onclick = ()=> go(current-1);
    btnNext.onclick = ()=> go(current+1);
    btnPlay.onclick = ()=>{
      if (!isVideo()) return;
      userStarted = true;
      const v = sections[current].querySelector('video');
      if (v) v.paused ? v.play() : v.pause();
    };
    btnMute.onclick = ()=>{
      if (!isVideo()) return;
      btnMute.classList.toggle('on');
      const v = sections[current].querySelector('video');
      if (v) v.muted = btnMute.classList.contains('on');
      toastMsg(v && v.muted ? 'Mute activado' : 'Sonido activado');
    };
    rateChips.forEach(ch=>{
      ch.onclick = ()=>{
        if (!isVideo()) return;
        rateChips.forEach(c=>c.classList.remove('active'));
        ch.classList.add('active');
        currentRate = parseFloat(ch.dataset.rate || '1');
        const v = sections[current].querySelector('video');
        if (v) v.playbackRate = currentRate;
        toastMsg(`${currentRate}×`);
      };
    });
    btnAuto.onclick = ()=>{
      autoplayNext = !autoplayNext;
      btnAuto.classList.toggle('on', autoplayNext);
      toastMsg(autoplayNext ? 'Auto siguiente: ON' : 'Auto siguiente: OFF');
    };

    // Gate inicio
    document.getElementById('start').onclick = async ()=>{
      userStarted = true;
      gate.style.display = 'none';
      btnMute.classList.add('on'); // asegura autoplay en móvil
      await renderTikToks();       // renderiza tus dos TikTok
      playVisible(current);
      setControlsState();
    };

    // Reanudar al volver a la pestaña
    document.addEventListener('visibilitychange', ()=>{
      if (!document.hidden && userStarted) playVisible(current);
    });

    // Atajos PC
    window.addEventListener('keydown', e=>{
      if (e.key==='ArrowDown'){ e.preventDefault(); go(current+1); }
      if (e.key==='ArrowUp'){   e.preventDefault(); go(current-1); }
      if (e.key===' '){         e.preventDefault(); btnPlay.click(); }
      if (e.key==='m'){         e.preventDefault(); btnMute.click(); }
    });
  </script>
</body>
</html>
